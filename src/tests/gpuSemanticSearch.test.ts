/**
 * Efficacy Tests for GPU Semantic Search
 * Tests semantic quality, embedding correctness, and GPU performance
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { DatabaseManager } from '../database/index.js';
import { KnowledgeGraphMcpTools } from '../tools/knowledgeGraphTools.js';
import type { SearchKnowledgeGraphInput } from '../schemas/tools/knowledgeGraph.js';
import { mkdtempSync, rmSync } from 'fs';
import { tmpdir } from 'os';
import { join } from 'path';

/**
 * Test corpus for semantic search evaluation
 * Tests ability to find conceptually related entities
 */
const TEST_CORPUS = [
  {
    id: 'entity-auth-login',
    type: 'function',
    name: 'authenticateUser',
    description: 'Validates user credentials and creates a session token using JWT',
    importance: 0.9,
    confidence: 0.95
  },
  {
    id: 'entity-auth-verify',
    type: 'function',
    name: 'verifyToken',
    description: 'Checks if a JWT token is valid and not expired',
    importance: 0.85,
    confidence: 0.9
  },
  {
    id: 'entity-db-query',
    type: 'function',
    name: 'executeQuery',
    description: 'Runs a SQL query against the PostgreSQL database',
    importance: 0.7,
    confidence: 0.8
  },
  {
    id: 'entity-db-transaction',
    type: 'function',
    name: 'beginTransaction',
    description: 'Starts a database transaction for atomic operations',
    importance: 0.8,
    confidence: 0.85
  },
  {
    id: 'entity-api-middleware',
    type: 'class',
    name: 'AuthMiddleware',
    description: 'Express middleware that validates authentication tokens before allowing access',
    importance: 0.88,
    confidence: 0.92
  },
  {
    id: 'entity-crypto-hash',
    type: 'function',
    name: 'hashPassword',
    description: 'Uses bcrypt to securely hash user passwords',
    importance: 0.9,
    confidence: 0.95
  },
  {
    id: 'entity-ui-loginform',
    type: 'component',
    name: 'LoginForm',
    description: 'React component that renders a login form with email and password fields',
    importance: 0.6,
    confidence: 0.75
  },
  {
    id: 'entity-math-calculate',
    type: 'function',
    name: 'calculateSum',
    description: 'Adds two numbers together and returns the result',
    importance: 0.3,
    confidence: 0.7
  }
];

/**
 * Semantic search test cases
 * Each case has a query and expected relevant entities (ordered by relevance)
 */
const SEMANTIC_TEST_CASES = [
  {
    query: 'user login and authentication',
    expectedTop3: ['entity-auth-login', 'entity-api-middleware', 'entity-auth-verify'],
    description: 'Should find authentication-related entities'
  },
  {
    query: 'JWT token validation',
    expectedTop3: ['entity-auth-verify', 'entity-auth-login', 'entity-api-middleware'],
    description: 'Should find token-related entities'
  },
  {
    query: 'database operations and transactions',
    expectedTop3: ['entity-db-transaction', 'entity-db-query'],
    description: 'Should find database-related entities'
  },
  {
    query: 'password security and hashing',
    expectedTop3: ['entity-crypto-hash', 'entity-auth-login'],
    description: 'Should find password-related entities'
  },
  {
    query: 'simple arithmetic operations',
    expectedTop3: ['entity-math-calculate'],
    description: 'Should find math-related entities'
  }
];

describe('GPU Semantic Search - Efficacy Tests', () => {
  let db: DatabaseManager;
  let tools: KnowledgeGraphMcpTools;
  let testRepoPath: string;

  beforeAll(async () => {
    // Create temporary test directory
    testRepoPath = mkdtempSync(join(tmpdir(), 'zmcp-semantic-test-'));

    // Initialize database and tools
    db = new DatabaseManager();
    tools = new KnowledgeGraphMcpTools(db);

    // Populate test corpus (without embeddings - let the service generate them)
    const kgService = db.getKnowledgeGraphService(testRepoPath);
    for (const entity of TEST_CORPUS) {
      await kgService.createEntity({
        id: entity.id,
        type: entity.type as any,
        name: entity.name,
        description: entity.description,
        importanceScore: entity.importance,
        confidenceScore: entity.confidence,
        properties: {},
        discoveredBy: 'test-suite'
        // Note: No embedding provided - will be generated by vectorService
      });
    }

    // Trigger embedding generation for all entities
    const vectorService = db.getVectorSearchService(testRepoPath);
    for (const entity of TEST_CORPUS) {
      await vectorService.updateEntityEmbedding(entity.id, entity.description);
    }
  }, 30000); // 30 second timeout for embedding generation

  afterAll(() => {
    try {
      rmSync(testRepoPath, { recursive: true, force: true });
    } catch (error) {
      console.error('Cleanup error:', error);
    }
  });

  describe('Semantic Quality - Conceptual Relevance', () => {
    SEMANTIC_TEST_CASES.forEach((testCase) => {
      it(testCase.description, async () => {
        const input: SearchKnowledgeGraphInput = {
          repository_path: testRepoPath,
          query: testCase.query,
          use_semantic_search: true,
          include_relationships: false,
          limit: 5,
          threshold: 0.5
        };

        const result = await tools['searchKnowledgeGraph'](input);

        expect(result.entities.length).toBeGreaterThan(0);

        // Extract entity IDs from results
        const resultIds = result.entities.map(e => e.id);

        // Check if expected top entities are in results
        const topExpected = testCase.expectedTop3;
        for (const expectedId of topExpected) {
          expect(resultIds).toContain(expectedId);
        }

        // Verify most relevant entity is in top 3 results
        const topResultIds = resultIds.slice(0, 3);
        expect(topResultIds.some(id => topExpected.includes(id))).toBe(true);

        console.log(`Query: "${testCase.query}"`);
        console.log(`Results: ${resultIds.join(', ')}`);
        console.log(`Expected in top 3: ${topExpected.join(', ')}`);
      });
    });
  });

  describe('Embedding Correctness', () => {
    it('should generate different embeddings for semantically different content', async () => {
      const kgService = db.getKnowledgeGraphService(testRepoPath);

      const authEntity = await kgService.getEntity('entity-auth-login');
      const mathEntity = await kgService.getEntity('entity-math-calculate');

      expect(authEntity?.embedding).toBeDefined();
      expect(mathEntity?.embedding).toBeDefined();

      // Embeddings should be different
      expect(authEntity?.embedding).not.toEqual(mathEntity?.embedding);

      // Calculate cosine similarity (should be low for unrelated concepts)
      const similarity = cosineSimilarity(
        authEntity?.embedding || [],
        mathEntity?.embedding || []
      );

      expect(similarity).toBeLessThan(0.7); // Low similarity for unrelated concepts
      console.log(`Auth vs Math similarity: ${similarity.toFixed(4)}`);
    });

    it('should generate similar embeddings for semantically related content', async () => {
      const kgService = db.getKnowledgeGraphService(testRepoPath);

      const authLogin = await kgService.getEntity('entity-auth-login');
      const authVerify = await kgService.getEntity('entity-auth-verify');

      expect(authLogin?.embedding).toBeDefined();
      expect(authVerify?.embedding).toBeDefined();

      // Calculate cosine similarity (should be high for related concepts)
      const similarity = cosineSimilarity(
        authLogin?.embedding || [],
        authVerify?.embedding || []
      );

      expect(similarity).toBeGreaterThan(0.6); // High similarity for related concepts
      console.log(`AuthLogin vs AuthVerify similarity: ${similarity.toFixed(4)}`);
    });

    it('should update embeddings correctly when description changes', async () => {
      const entityId = 'test-update-embedding';
      const kgService = db.getKnowledgeGraphService(testRepoPath);

      // Create entity with initial description
      await kgService.createEntity({
        id: entityId,
        type: 'function',
        name: 'testFunction',
        description: 'Initial description about authentication',
        importanceScore: 0.5,
        confidenceScore: 0.5,
        properties: {},
        discoveredBy: 'test'
      });

      // Generate initial embedding
      const vectorService = db.getVectorSearchService(testRepoPath);
      await vectorService.updateEntityEmbedding(entityId, 'Initial description about authentication');

      const entity1 = await kgService.getEntity(entityId);
      const initialEmbedding = entity1?.embedding;

      expect(initialEmbedding).toBeDefined();

      // Update description to something completely different
      await kgService.updateEntity(entityId, {
        description: 'Completely different description about database operations'
      });

      // Re-embed with new description
      await vectorService.updateEntityEmbedding(entityId, 'Completely different description about database operations');

      const entity2 = await kgService.getEntity(entityId);
      const updatedEmbedding = entity2?.embedding;

      expect(updatedEmbedding).toBeDefined();

      // Embeddings should be different
      expect(initialEmbedding).not.toEqual(updatedEmbedding);

      // Similarity between old and new should be low
      const similarity = cosineSimilarity(initialEmbedding || [], updatedEmbedding || []);
      expect(similarity).toBeLessThan(0.8);

      console.log(`Embedding change similarity: ${similarity.toFixed(4)}`);
    });
  });

  describe('Search Threshold Sensitivity', () => {
    it('should respect similarity threshold', async () => {
      const highThreshold: SearchKnowledgeGraphInput = {
        repository_path: testRepoPath,
        query: 'user authentication',
        use_semantic_search: true,
        limit: 10,
        threshold: 0.9 // Very high threshold
      };

      const lowThreshold: SearchKnowledgeGraphInput = {
        repository_path: testRepoPath,
        query: 'user authentication',
        use_semantic_search: true,
        limit: 10,
        threshold: 0.5 // Low threshold
      };

      const highResults = await tools['searchKnowledgeGraph'](highThreshold);
      const lowResults = await tools['searchKnowledgeGraph'](lowThreshold);

      // Low threshold should return more results
      expect(lowResults.entities.length).toBeGreaterThanOrEqual(highResults.entities.length);

      console.log(`High threshold (0.9): ${highResults.entities.length} results`);
      console.log(`Low threshold (0.5): ${lowResults.entities.length} results`);
    });
  });

  describe('Performance Metrics', () => {
    it('should complete semantic search within reasonable time', async () => {
      const startTime = Date.now();

      const input: SearchKnowledgeGraphInput = {
        repository_path: testRepoPath,
        query: 'authentication and authorization',
        use_semantic_search: true,
        limit: 10,
        threshold: 0.6
      };

      const result = await tools['searchKnowledgeGraph'](input);

      const endTime = Date.now();
      const duration = endTime - startTime;

      expect(result.entities.length).toBeGreaterThan(0);
      expect(duration).toBeLessThan(5000); // Should complete in less than 5 seconds

      console.log(`Search completed in ${duration}ms`);
      console.log(`Processing time from metadata: ${result.search_metadata.processing_time}ms`);
    });

    it('should handle bulk search efficiently', async () => {
      const queries = [
        'authentication',
        'database',
        'password',
        'middleware',
        'transaction'
      ];

      const startTime = Date.now();

      const results = await Promise.all(
        queries.map(query =>
          tools['searchKnowledgeGraph']({
            repository_path: testRepoPath,
            query,
            use_semantic_search: true,
            limit: 5,
            threshold: 0.6
          })
        )
      );

      const endTime = Date.now();
      const totalDuration = endTime - startTime;
      const avgDuration = totalDuration / queries.length;

      expect(results.every(r => r.entities.length > 0)).toBe(true);
      expect(avgDuration).toBeLessThan(3000); // Average less than 3 seconds per query

      console.log(`Bulk search: ${queries.length} queries in ${totalDuration}ms`);
      console.log(`Average: ${avgDuration.toFixed(0)}ms per query`);
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty query gracefully', async () => {
      const input: SearchKnowledgeGraphInput = {
        repository_path: testRepoPath,
        query: '',
        use_semantic_search: true,
        limit: 5,
        threshold: 0.6
      };

      // Should either return empty results or handle gracefully
      const result = await tools['searchKnowledgeGraph'](input);
      expect(result.entities).toBeDefined();
      expect(Array.isArray(result.entities)).toBe(true);
    });

    it('should handle very long query strings', async () => {
      const longQuery = 'authentication and authorization with JWT tokens and session management ' +
        'including password hashing and secure storage of credentials in PostgreSQL database ' +
        'with ACID transactions and rollback capabilities for enterprise applications'.repeat(3);

      const input: SearchKnowledgeGraphInput = {
        repository_path: testRepoPath,
        query: longQuery,
        use_semantic_search: true,
        limit: 5,
        threshold: 0.6
      };

      const result = await tools['searchKnowledgeGraph'](input);
      expect(result.entities).toBeDefined();
      expect(result.entities.length).toBeGreaterThan(0);
    });

    it('should handle queries with no matches above threshold', async () => {
      const input: SearchKnowledgeGraphInput = {
        repository_path: testRepoPath,
        query: 'quantum computing and blockchain cryptography',
        use_semantic_search: true,
        limit: 5,
        threshold: 0.95 // Very high threshold for unrelated query
      };

      const result = await tools['searchKnowledgeGraph'](input);
      // May return empty or very few results
      expect(result.entities).toBeDefined();
      expect(Array.isArray(result.entities)).toBe(true);
    });
  });
});

/**
 * Calculate cosine similarity between two vectors
 */
function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length || a.length === 0) {
    return 0;
  }

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    return 0;
  }

  return dotProduct / (normA * normB);
}